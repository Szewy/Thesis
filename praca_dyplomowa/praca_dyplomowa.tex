\documentclass[a4paper,12pt,twoside,openany]{report}

\usepackage{polski}
\usepackage{helvet}
\usepackage[T1]{fontenc}
\usepackage{anyfontsize}
\usepackage[utf8]{inputenc}
\usepackage[pdftex]{graphicx}
\usepackage{tabularx}
\usepackage{array}
\usepackage[polish]{babel}
\usepackage{subfigure}
\usepackage{amsfonts}
\usepackage{verbatim}
\usepackage{indentfirst}
\usepackage[pdftex]{hyperref}
\usepackage{amsmath}
\usepackage{float}
\usepackage{subfigure}
\usepackage{tabularx}
\usepackage{enumitem}
\usepackage{listings}

\setlist[itemize]{noitemsep, topsep=0pt}

\newcommand{\ImgPath}{.}
\newcommand{\TODO}{\textbf{TODO}}
\newcommand{\tech}{\texttt}

\def\oprawa{1.05cm}
\addtolength{\oddsidemargin}{\oprawa}
\addtolength{\evensidemargin}{-\oprawa}

\usepackage{multirow}
\usepackage{enumitem}	
\setlist{listparindent=\parindent, parsep=\parskip} 

\usepackage{prmag2017} 

\title{Rozpoznawanie gestów na przykładzie gry papier, kamień, nożyce}

\author{Adrian Szewczyk}
\nrindeksu{279074}

\opiekun{mgr inż. Marek Wdowiak}
\terminwykonania{1 lutego 2018} 
\rok{2018}


\opinie{
  \input{opiniaopiekuna.tex}
  \newpage
  \input{recenzja.tex}
}

\streszczenia{
  \input{streszczenia.tex}
}

\begin{document}
\maketitle


\chapter{Wstęp}
\section{Wprowadzenie}
Istotną rolę w życiu społecznym pełnią gesty. Dodatkowa mowa niewerbowana może przekazać zdecydowanie więcej informacji niż tylko słowa wypowiedziane przez nadawcę. Gesty mogę, również zastąpić słowa i być wykorzystywane jako zamiennik na słyszalne słowa. Przykładem tego jest język migowy, który pozwala na wzajemną komunikację ludzi głuchych. Oprócz samej mowy, gesty mają też inne zastosowania. Przykładem takim może być gra papier, kamień, nożyce. W której każdy z graczy pokazuje jeden z trzech dostępnym gestów. I w zależności od kombinacji gestów pokazanych przez graczy określany jest zwycięzca.

Klasyfikacja gestów jest powszechnym problem przetwarzania obrazów. Jest to temat obszerny i coraz lepiej zbadanym problem nauki. Klasyfikacja gestów ma szerokie zastosowanie. Jedną zalet rozpoznawania gestów jest możliwość sterowania naszym smartfonem za pomocą ruchu rąk. Po wykonaniu gestu, a następnie po rozpoznaniu go przez  oprogramowanie telefonu wykonywana jest określona akcja. Innym wykorzystaniem klasyfikacji gestów jest sterowanie gier, gdzie jako przykład można podać konsolę Nintendo Wii.

\section{Cel pracy}
W swojej pracy dyplomowej będę chciał przedstawić sposób podejścia do problemu klasyfikacji gestów, a następnie zaimplementować działające rozwiązanie i wykorzystać go w praktyce, na przykładzie gry papier, kamień, nożyce. Ogólnym celem będzie stworzenie klasyfikatora, który pozwoli na automatyczne rozpoznawanie gestów, które są wykorzystywane podczas gry papier, kamień, nożyce.

\chapter{Przetwarzanie obrazów}
\section{Cyfrowe przetwarzanie obrazów binarnych}
Cyfrowe przetwarzanie obrazów binarnych jest to dziedzina przetwarzania obrazów cyfrowych zajmująca się algorytmami obróbki obrazów binarnych. 

\begin{figure}[H]	
	\centering
	\includegraphics[width=0.7\textwidth]{\ImgPath/rys/bin.png}
	
	\caption{  \textbf{Przykładowy obraz binarny}}
\end{figure}

Obrazy binarne składają się z pikseli, które mogą przyjmować jedynie dwie wartości. Piksele takie możmy oznaczać różnymi symboli, np. 0/1, false/true czy też (0,0,0)/(255,255,255). Podczas interpretacji obrazu jedne z pikseli można traktować jako tło, inne zaś jako część obiektu. Dzięki czemu jesteśmy wstanie rozróżnić interesującą nas część obrazu od pozostałej części. 

\section{OpenCV}
OpenCV (Open Source Computer Vision Library) jest to otwartoźródłowa biblioteka wykorzystywana przy rozpoznawaniu obrazów oraz przy uczeniu maszynowym. Została napisana w języku C przez programistów z firmy Intel w 1999 roku.

W późniejszym czasie kolejne części biblioteki były także pisane w języku C++. OpenCV umożliwia pisanie kodów nie tylko w językach C i C++ ale również mamy możliwość wykorzystywania tej biblioteki w językach Python, Java czy też Matlab. Co więcej zostały udostępnione nakładki do języków takich jak C\#, Perl, Ruby czy Haskell aby móc również wykorzystywać zalety  biblioteki. 

OpenCV udostępnia zaawansowaną funkcjonalność  w szeroko rozumianym pojęciu rozpoznawaniu obrazów:

\begin{itemize}
	\item przetwarzania obrazów
	\item klasyfikowaniu wzorców
	\item dokładnych pomiarów obrazów
\end{itemize}

Jako główne zalety OpenCV możemy wyróżnić, że jest on darmowy oraz otwartoźródłowy. Zawiera bogaty zakres funkcjonalności, a kod biblioteki został napisany w sposób zoptymalizowanym, tak aby operacje wymagające dużej mocy obliczeniowej czy działające w czasie rzeczywistym mogły wykonywać się możliwie jak najszybciej.

OpenCV znalazło zastosowanie w wielu dziedzinach naszego codziennego życia:
\begin{itemize} 
	\item medycyna
	\item robotyka
	\item samochody autonomiczne
	\item systemy antywłamaniowe 
	\item systemy zabezpieczające
	\item rozpoznawanie gestów
	\item segmentacja obiektów
	\item wykrywanie ruchu
	\item rozszerzona rzeczywistość
	\item rozpoznawanie obiektów
\end{itemize}


\section{Operacje morfologiczne}
Operacje morfologiczne to podstawowe operacje przetwarzania obrazów. Pozwalają na złożone czynności związane z analizą kształtu poszczególnych elementów obrazu oraz położeniem względem siebie. W wyniku operacji struktura obiektu na obrazie zostaje zmieniona, w celu osiągnięcia określonych rezultatów. 
Operacje morfologiczne najczęściej stosuje się dla obrazów binarnych, dla których są to operacji podstawowe oraz jedne z najważniejszych. Dzięki nim jesteśmy wstanie wyszczególnić interesujące nas części czy też przefiltrować nasz obraz. Najczęściej wykorzystywane operacje morfologiczne to: erozja, dylatacja, otwarcie oraz zamknięcie. Wymienione operacje można ze sobą łączyć, tworząc zaawansowane systemy analizy.

Operacje morfologiczne modyfikują wartość pikseli biorąc pod uwagę wartości pikseli ich otaczających. Liczbę punktów otoczenia określa tzw. element strukturalny, który definiuje wartości i ich rozmieszenie w otoczeniu. Szablon strukturalny(element strukturalny) posiada jeden wyróżniony punkt, nazywany punktem centralnym.

Najczęściej stosowanymi elementami strukturalnymi są kwadrat o boku o nieparzystej liczbie pikseli, które wszystkie przyjmują wartość równą 1 oraz element strukturalny, który aproksymuje swoim kształtem koło.

\begin{figure}[H]
	\centering
	\subfigure[]
	{\label{fig:a}\includegraphics[width=0.3\textwidth]{\ImgPath/rys/elementy_strukturalne/1.png}}
	\subfigure[]
	{\label{fig:b}\includegraphics[width=0.3\textwidth]{\ImgPath/rys/elementy_strukturalne/2.png}}
	\subfigure[]
	{\label{fig:b}\includegraphics[width=0.3\textwidth]{\ImgPath/rys/elementy_strukturalne/3.png}}
	\caption{Przykładowe elementy strukturalne, gdzie punkt w kolorze czerwonym jest punktem centralnym}
\end{figure}

\paragraph{Etapy przekształceń morfologicznych:}
\begin{enumerate}
	\item Szablon strukturalny jest przesuwany po całym obiekcie, tak aby punkt centralny szablonu był analizowanym pikselem
	\item Następuje porównanie otoczenia analizowanego piksela z elementem strukturalnym
	\item W zależności od stosowanej operacji morfologicznej wartość analizowanego piksela zmienia się lub też pozostaje bez zmian
\end{enumerate}

\paragraph{Erozja:}\mbox{} \\
Jest to operacja zwężania i zmniejszania poprzez usunięcie pikseli granicznych. Usuwa wszystkie mniejsze obiekty, które możemy zinterpretować jako szumy. 

\paragraph{Etapy operacji erozji:}
\begin{enumerate}
	\item Element strukturalny przesuwany jest iteracyjnie po całym obiekcie,  tak aby punkt centralny szablonu był analizowanym pikselem
	\item Porównuje się otoczenie analizowanego piksela z elementem strukturalnym
	\item  Jeżeli przynajmniej jeden piksel z otoczenia objętego przez szablon strukturalny ma wartość równą 0, to punkt centralny przyjmuje wartość 0. Jeżeli zaś taki przypadek nie wystąpił piksel centralny zachowuje swoją poprzednią wartość
\end{enumerate}

\begin{figure}[H]
	\centering
	\subfigure[Obraz początkowy]
		{\label{fig:a}\includegraphics[width=0.3\textwidth]{\ImgPath/rys/operacje_morfologiczne/szablon.png}}
	\subfigure[Element struturalny, punkt czerwony jest punktem centralnym]
		{\label{fig:b}\includegraphics[width=0.3\textwidth]{\ImgPath/rys/operacje_morfologiczne/e.png}}
	\subfigure[Obraz wyjściowy]
		{\label{fig:b}\includegraphics[width=0.3\textwidth]{\ImgPath/rys/operacje_morfologiczne/erozja.png}}
	\caption{Operacja erozji na obrazie binarnym}
\end{figure}

\paragraph{Dylatacja:}\mbox{} \\
Jest to operacja rozszerzania i zwiększania. Pozwala na wypełnienie dziur binarnych w obiektach. Jeżeli dwa obiekty są położone blisko siebie, może nastąpić złączenie w jeden obiekt.

\paragraph{Etapy operacji erozji:}
\begin{enumerate}
	\item Element strukturalny przesuwany jest iteracyjnie po całym obiekcie, tak aby punkt centralny szablonu był analizowanym pikselem
	\item Porównuje się otoczenie analizowanego piksela z elementem strukturalnym
	\item Jeżeli przynajmniej jeden piksel z otoczenia objętego przez szablon strukturalny ma wartość równą 1, to punkt centralny przyjmuje również wartość 1. Jeżeli zaś wszystkie piksele z otoczenia piksela centralnego określonego przez element strukturalny mają wartość 0 to wówczas piksel centralny przyjmuje wartość 0.
\end{enumerate}

\begin{figure}[H]
	\centering
	\subfigure[Obraz początkowy]
	{\label{fig:a}\includegraphics[width=0.3\textwidth]{\ImgPath/rys/operacje_morfologiczne/szablon.png}}
	\subfigure[Element struturalny, punkt czerwony jest punktem centralnym]
	{\label{fig:b}\includegraphics[width=0.3\textwidth]{\ImgPath/rys/operacje_morfologiczne/e.png}}
	\subfigure[Obraz wyjściowy]
	{\label{fig:b}\includegraphics[width=0.3\textwidth]{\ImgPath/rys/operacje_morfologiczne/dylatacja.png}}
	\caption{Operacja dylatacji na obrazie binarnym}
\end{figure}

\paragraph{Otwarcie:}\mbox{} \\
Operacja otwarcia morfologicznego jest definiowana przez połączenie metod erozji oraz dylatacji. Metoda ta wygładza obiekt, usuwa niechciane szumy, a w dodatku nie modyfikuje znacząco wielkości obiektów tak jak to jest w przypadku zastosowania operacji erozji czy dylatacji.

\paragraph{Etapy operacji otwarcia:}
\begin{enumerate}
	\item Wykonywana jest operacja erozji na zadanym obrazie
	\item Wykonywana jest operacja dylatacji na obraz, który jest wynikiem erozji z punktu 1.
\end{enumerate}

\begin{figure}[H]
	\centering
	\subfigure[Obraz początkowy]
	{\label{fig:a}\includegraphics[width=0.3\textwidth]{\ImgPath/rys/operacje_morfologiczne/szablon.png}}
	\subfigure[Element struturalny, punkt czerwony jest punktem centralnym]
	{\label{fig:b}\includegraphics[width=0.3\textwidth]{\ImgPath/rys/operacje_morfologiczne/e.png}}
	\subfigure[Obraz wyjściowy]
	{\label{fig:b}\includegraphics[width=0.3\textwidth]{\ImgPath/rys/operacje_morfologiczne/otwarcie.png}}
	\caption{Operacja otwarcia na obrazie binarnym}
\end{figure}

\paragraph{Zamknięcie:}\mbox{} \\
Operacja zamknięcia łączy w sobie połączenie dwóch metod dylatacji oraz erozji, analogicznie jak było w przypadku operacji zamknięcia, jednakże w odwrotnej kolejności. W rezultacie uzyskujemy połączenie obiektów o zbliżonych odległościach, wypełnienie dziur w obiektach, jednakże końcowy kształt obiektu zostaje w dużym stopniu zmieniony w stosunku do kształtu przed zastosowaniem operacji zamknięcia.

\paragraph{Etapy operacji otwarcia:}
\begin{enumerate}
	\item Wykonywana jest operacja dylatacji na zadanym obrazie
	\item Wykonywana jest operacja erozji na obraz, który jest wynikiem erozji z punktu 1.
\end{enumerate}

\begin{figure}[H]
	\centering
	\subfigure[Obraz początkowy]
	{\label{fig:a}\includegraphics[width=0.3\textwidth]{\ImgPath/rys/operacje_morfologiczne/szablon.png}}
	\subfigure[Element struturalny, punkt czerwony jest punktem centralnym]
	{\label{fig:b}\includegraphics[width=0.3\textwidth]{\ImgPath/rys/operacje_morfologiczne/e.png}}
	\subfigure[Obraz wyjściowy]
	{\label{fig:b}\includegraphics[width=0.3\textwidth]{\ImgPath/rys/operacje_morfologiczne/zamkniecie.png}}
	\caption{Operacja zamknięcia na obrazie binarnym}
\end{figure}

\section{Filtry ruchu}
Filtry ruchu są wykorzystywane do generowania maski binarnej zawierającej poruszające się obiekty. Tak zwany z ang. background subtraction wykorzystuje różnicę z dwóch różnych klatek z pliku wideo. Odejmowanie dwóch klatek pozwala nam prześledzić, które z części obrazów zmieniły się. Różnica dwóch pikseli da nam wartość niezerową, tylko wtedy jeżeli z analizowanych klatkach wartość odpowiadających sobie pikseli różni się, co interpretujemy, że ta część obrazu poruszyła się. 

\begin{figure}[H]
	\centering
	\subfigure[Tło]
	{\label{fig:a}\includegraphics[width=0.3\textwidth]{\ImgPath/rys/bs/tlo.jpg}}
	\subfigure[Zdjęcie]
	{\label{fig:b}\includegraphics[width=0.3\textwidth]{\ImgPath/rys/bs/img.jpg}}
	\subfigure[Różnica zdjęcia i tła ]
	{\label{fig:b}\includegraphics[width=0.3\textwidth]{\ImgPath/rys/bs/bin.jpg}}
	\caption{Przykładowe metody background subtractor z biblioteki OpenCV}
\end{figure}

OpenCV w swojej bibliotece posiada wiele gotowych rozwiązać do wykrywania obiektów w ruchu. Jako jedne z najczęściej wykorzystywanych metod możemy wyróżnić następujące:
\begin{itemize} 
	\item BackgroundSubtractorMOG
	\item BackgroundSubtractorMOG2
	\item BackgroundSubtractorGMG
\end{itemize} 
	
\begin{figure}[H]
	\centering
	\subfigure[BackgroundSubtractorMOG]
	{\label{fig:a}\includegraphics[width=0.3\textwidth]{\ImgPath/rys/bs/mog.png}}
	\subfigure[BackgroundSubtractorMOG2]
	{\label{fig:b}\includegraphics[width=0.3\textwidth]{\ImgPath/rys/bs/mog2.png}}
	\subfigure[BackgroundSubtractorGMG]
	{\label{fig:b}\includegraphics[width=0.3\textwidth]{\ImgPath/rys/bs/gmg.png}}
	\caption{Przykładowe metody background subtractor z biblioteki OpenCV}
\end{figure}

W celu polepszenia efektów, należy pozbyć się niedokładnej segmentacji oraz możliwych szumów,  które mogą wystąpić podczas analizy. Są one spowodowane różnymi odbiciami, cieniami czy innymi niezauważalnymi ruchami. Wówczas należy wykorzystać przedstawione wcześniej operacje morfologiczne, które poprawią nam wykonaną detekcję.

\section{Detekcja kolorów}
Celem detekcji kolorów jest wygenerowanie obrazu binarnego, w którym piksele binarne  o wartości prawdy oznaczają piksele, które na zadanym obrazie są w określonym przedziale kolorów. Jeżeli dany piksel nie należy do określonego  przedziału, wówczas obraz binarny w tym punkcie otrzymuje wartość fałszu. Detekcja taka pozwala na wyłuskania tylko obiektów o określonym koloru.

Detekcja jest bardzo wrażliwa na różnego rodzaju szumy. Częstymi powodem występowanie ich jest zmienne oświetlenie. Obiekt przy różnym świetle możemy odbierać kolorystycznie całkowicie inaczej. W przypadku, kiedy analizujemy dynamiczny ruch, wówczas dynamika również może wpływać na kolorystykę danego obiektu. Te wszystkie czynniki, sprawiają, że detekcja określonego koloru nie jest zadaniem takim prostym. 

Aby polepszyć efekt końcowy detekcji obiektów o określonym kolorze, należy analogicznie jak w przypadku detekcji ruchu, wykorzystać odpowiednie operacje morfologiczne. 

Przy detekcji kolorów tradycyjny model rgb (red, green, blue), najczęściej nie jest wystarczająco dobrym modelem. W zadaniach takich zdecydowanie lepiej sprawuje się model HSV.

\begin{figure}[H]	
	\centering
	\includegraphics[width=0.4\textwidth]{\ImgPath/rys/hsv.png}
	
	\caption{  \textbf{Model HSV}}
\end{figure}

HSV (ang. Hue Saturation Value) jest to model opisu przestrzeni barw, wprowadzony przez Alveya Raya Smitha w 1978 roku.

Model składa się z następujących części: barwa, nasycenie, wartość. Geometrycznie możemy go przedstawić jako stożek. Wszystkie barwy wywodzą się ze światła białego, czyli ze środka stożka. Składowa H, oznacza barwę w postaci kąta od 0 do 360 stopni. Składowa S czyli nasycenie, geometrycznie to odległość od środka na promieniu podstawy. Decyduje o bliskości naszego koloru do koloru białego. Ostatnia składowa V, to wartość oznaczająca wysokość na stożku, co możemy traktować jako jasność naszego koloru. Czym mniejsza jej wartość tym kolor ciemniejszy.

\chapter{Sztuczna inteligencja}
\section{Sieci neuronowe}
	Sieci neuronowe możemy traktować jako model czarnej skrzynki. Dla określonych danych wejściowych uzyskujemy wartości wyjściowe.
	
	\begin{figure}[H]	
		\centering
		\includegraphics[width=0.9\textwidth]{\ImgPath/rys/czarna_skrzynka.png}
		
		\caption{  \textbf{Sieć neuronowa jako model czarnej skrzynki}}
	\end{figure}
	
	Sztuczne sieci neuronowe są to systemy komputerowe zainspirowane biologiczną siecią neuronowa ludzkiego mózgu. Sieci neuronowe nie są algorytmami, jednakże są ogólnym modelem wykorzystywanym przy uczeniu maszynowym i przy przetwarzaniu danych wejściowych.
	
	Sieci neuronowe są to zbiory połączonych ze sobą sztucznych neuronów. W biologicznym układzie mózgu, połączenia pomiędzy dwoma neuronami nazywamy synapsami. W sztucznych sieciach neuronowych połączenie to często nazywamy krawędzią. 
	
	Czarna skrzynka to tzw. warstwa ukryta. Znajdują się w niej neurony ściśle ze sobą powiązane. Każdy z neuronów ma w sobie pewną wartość, powszechnie oznaczaną przez wartość liczby rzeczywistej. Każda krawędź w sieciach neuronowych posiada pewną określoną wagę. Zwiększanie lub zmniejszanie wag zmienia siłę sygnału w danym połączeniu pomiędzy neuronami.
	
	\begin{figure}[H]	
		\centering
		\includegraphics[width=0.7\textwidth]{\ImgPath/rys/siec_neuronowa.png}
		
		\caption{  \textbf{Przykładowa sieć neuronowa}}
	\end{figure}
	
	Na rysunku 3.2 zaprezentowano przykładowy schemat sieci neuronowej. Sieć ta zawiera dwa elementy wejścia, które są przekazywane do każdego neuronu z pierwszej warstwy ukrytej. Model posiada dwie warstwy ukryte, które są oznaczone na modelu kolorem niebieskim. Pierwsza z nich zawiera cztery neurony, zaś druga warstwa posiada dwa neurony. Ostatnia warstwa modelu, czyli warstwa wyjściowa oznaczona kolorem żółtym posiada dwa neurony, których wyjście jest interpretowane jako rezultat działania całej sztucznej sieci neuronowej.
	
	Sztuczne neurony na podstawie zsumowanych iloczynów wartości na wejściowych oraz wartości wag odpowiadających im krawędziom, wykonują pewną funkcję tak zwaną funkcję aktywacji, której rezultat jest traktowany jako wyjście dla pojedynczego neuronu. 
	
	\begin{figure}[H]	
		\centering
		\includegraphics[width=0.9\textwidth]{\ImgPath/rys/neuron.png}
		
		\caption{  \textbf{Przykład pojedynczego neuronu}}
	\end{figure}
	
	\paragraph{Funkcje aktywacji:}
		\mbox{} \\
		Wartość funkcji aktywacji dla danego neuronu, określa wartość wyjściową tego neuronu.
		\begin{figure}[H]
			\centering
			\subfigure[Funkcja ReLU]
			{\label{fig:a}\includegraphics[width=0.3\textwidth]{\ImgPath/rys/funkcje_aktywacji/relu.png}}
			\subfigure[Funkcja Sigmoid]
			{\label{fig:b}\includegraphics[width=0.3\textwidth]{\ImgPath/rys/funkcje_aktywacji/sigmoid.png}}
			\subfigure[Funkcja Tanh]
			{\label{fig:b}\includegraphics[width=0.3\textwidth]{\ImgPath/rys/funkcje_aktywacji/tanh.png}}
			\caption{Przykładowe funkcje aktywacji wykorzystywane w sieciach neuronowych}
		\end{figure}
	
		Często używa się tej samej funkcji aktywacji dla tej samej warstwy, a niejednokrotnie wykorzystujemy tą samą funkcję aktywacji nawet do całej sieci neuronowej. 
		
		Softmax jest przykładem funkcji aktywacji, którą często wykorzystuje się jako funkcję aktywacji w warstwie wyjściowej. Właściwość opisująca tę funkcję aktywacji jest ta, że suma wartości aktywacji dla całej warstwy jest równa 1. Wykorzystując tę normalizację, możemy wartości wyjściowe neuronów zinterpretować jako prawdopodobieństwo należności do poszczególnych klas, które reprezentowane są przez neurony wyjściowe.  
		
		\paragraph{Uczenie sieci neuronowych:}
			\mbox{} \\
			\indent
			Przy uczeniu nadzorowanym sieci podstawowym algorytmem jest wsteczna propagacja błędu. Znając wartości wyjściowe dla danego zbioru danych wejściowych jesteśmy wstanie policzyć błąd działania sieci. Ten błąd jest przekazywany iteracyjnie do połączonych w poprzednich. Uczenie sieci polega na dostrajaniu wartości wag, w zależności od błędu w danym neuronie. Ważnym parametrem przy uczeniu sieci jest parametr szybkości uczeniu. Określa on szybkość uczenia się sieci neuronowych. 
		
	\paragraph{Wykorzystanie sieci neuronowych:}
		\begin{itemize}
			\item Rozpoznawanie obrazów
			\item Sterowanie gestami
			\item Przewidywanie wartości akcji spółek giełdowych
			\item Generowanie plików wideo z obrazka
			\item Rozpoznawanie mowy
			\item Tworzenie opisu zdjęć
			\item Przewidywanie prognozy pogody
			\item Diagnostyka medyczna
			\item Ocena zdolności kredytowej
			\item Rekomendowanie reklam

		\end{itemize}

\section{Klasyfikatory}
Klasyfikacja to wyznaczanie klasy decyzyjnej do której należy nowy, nieznany dotąd obiekt. Metody klasyfikacji możemy podzielić na dwie kategorie. Pierwsza z nich jest  klasyfikacją nadzorowaną, druga zaś to klasyfikacja nienadzorowana. 

Klasyfikacja nadzorowana w momencie uczenia klasyfikatora tzn. podawania zbioru danych treningowych, musi w sobie zawierać etykietę(atrybut decyzyjny), która oznacza do jakiej klasy należy ten konkretny przypadek. Zaś w przypadku ucznia nienadzorowanego atrybutu decyzyjnego nie istnieje.

\subsection{Klasyfikator KNN}
Klasyfikator KNN jest przykładem klasyfikacji nadzorowanej. Zbiór treningowy zawiera w sobie cechy dla klasyfikatora czyli atrybuty oraz atrybut decyzyjny, który określa przynależność do konkretnej klasy. Elementami wejścia dla stworzenia klasyfikatora jest zbiór uczący. Wyjściem jest klasyfikator, który wykorzystujemy do określania atrybutów decyzyjnych nieznanych wcześniej obiektów.

\paragraph{Po utworzeniu klasyfikatora bazującego na zbiorze uczącym, szacowanie atrybutu decyzyjnego odbywa się w następujących krokach: }
\begin{enumerate}
	\item Ustalamy wartość k
	\item Znajdujemy k obiektów treningowych, najbliższych naszemu obiektowi
	\item Analizowany obiekt należy do klasy najliczniejszej w znalezionym zbiorze z podpunktu 2
\end{enumerate}
	
Ocenianie odległości pomiędzy dwoma obiektami polega na umieszczaniu obiektów w przestrzeni d-wymiarowej, gdzie d opisuje ilość atrybutów dla obiektów. Metryka miary może odbywać się w różny sposób. Najczęściej jest to miara euklidesowa, jednakże możemy również wykorzystać inne miary tj. Manhattana czy Minkowskiego. 

Po znalezieniu k-najbliższych sąsiadów, atrybut decyzyjny przyjmuje wartość od najbardziej licznej klasy w wyznaczonym zbiorze.

\begin{figure}[H]	
	\centering
	\includegraphics[width=0.6\textwidth]{\ImgPath/rys/knn.png}
	
	\caption{Przykład klasyfikatora KNN dla trzech sąsiadów}
\end{figure}

Na zaprezentowanym przykładzie możemy przeanalizować działanie klasyfikatora KNN dla trzech sąsiadów. Dla wyuczonego klasyfikatora KNN, próbkami, która na grafice są zaprezentowane jako kółeczka, zaś ich kolor pokazuje do jakiej klasy obiektu należy. Naszym zadaniem jest określenie atrybuty decyzyjnego dla próbki, która została zaznaczona jako mniejsze koło niebieskie. W pierwszym kroki zaznaczamy sąsiedztwo trzech sąsiadów, na ilustracji zaznaczono go dużym kołem niebieskim. Można zaobserwować, że w sąsiedztwie mamy dwa obiekty klasy czerwonej oraz jeden klasy żółtej. Wybór klasy naszego obiektu jest większościowy, co oznacza, że nasza nowa nieznana dotąd próbka danych zostanie zakwalifikowana do klasy czerwonej.


\subsection{Dobór i ocena cech}
Podstawowym elementem tworzenia klasyfikatora jest dobór odpowiednich do niego cech na których będzie bazował. Źle dobrane elementy wejścia spowodują niedokładną klasyfikację. Dlatego tak bardzo ważne jest odpowiedni dobór cech opisujących.

Ważnym etapem dla każdej cechy była jej normalizacja danych, aby dana cecho nie powodowała większego wpływy od innych czy też wpływa nieznacząco w stosunku do innych. Przykładem normalizacji jest standaryzacja, którą możemy przedstawić zgodnie ze wzorem: $ Z = \dfrac{x - \mu}{\sigma} $, gdzie 
\\ x - wartość przed normalizacją, \\ $\mu$ - średnia, \\ $\sigma$ - odchylenie standardowe

\paragraph{Warunki dobrej cechy diagnostycznej: }
\begin{itemize}
	\item Powinny być wielkościami z podobnego zakresu
	\item Wartości danej cechy w obrębie określonej klasy powinny być do siebie możliwie jak najbardziej zbliżone
	\item Powinny być mało wrażliwe na szum
	\item Ta sama cecha powinna przyjmować różne wartości w przypadku różnych klas
	\item Ogólna liczba cech diagnostycznych nie może być zbyt duża
\end{itemize}
\mbox{} \\
Warunkiem dobrej cechy diagnostycznej, jest to, że ta sama cecha w obrębie różnych klas powinna przyjmować jak najbardziej różne wartości. Przy diagnostyce tego warunku można wykorzystać średnią arytmetyczną wartości danej cechy w poszczególnych klasach.

Kolejnym warunkiem na jaki warto zwrócić uwagę podczas oceny cech jest jej odchylenie standardowe w obrębie określonej klasy. Odchylenie standardowe można określić wzorem: \\
$ \sigma = {\sqrt {\operatorname {E} ((X-\operatorname {E} (X))^{2})}} $, gdzie \\
X - zmienna \\
E - wartość oczekiwana \\

Opisuje ono rozproszenie cechy w obrębie określonej klasy, co implikuje, że dobrze dobrana cecha charakteryzuje się jak najmniejszym rozproszeniem.

\paragraph{Przykładowe cechy możliwe do wykorzystania do opisu masek binarnych: }
\begin{itemize}
	\item Stosunek szerokości do wysokości obrazu
	\item Stosunek powierzchni obiektu binarnego do powierzchni całego obrazu
	\item Stosunek powierzchni otoczki wypukłej na obiekcie binarnym do powierzchni całego obrazu
	\item Stosunek półosi małej do dużej elipsy opisanej na obiekcie binarnym 
	\item Wartości punktów końcowych obiektu binarnego
	\item Orientacja obiektu binarnego
\end{itemize}
\mbox{} \\
Przy wyborze odpowiednich cech ważnym elementem jest ich ocena, aby sprawdzić czy wybrana cecha będzie wymierny wpływ na prawidłową klasyfikację.

\section{Python}
Jest to interpretowany, obiektowy język wysokiego poziomu. Używany jest w szerokiej gamie  aplikacjach. Jest językiem ogólnego przeznaczenia, co oznacza, że może zostać wykorzystany praktycznie do wszystkiego. Jest rozwijany jako projekt otwartoźródłowy. Pojawił się w roku 1991, zaprojektowany przez holenderskiego programistę Guido van Rossum.

\paragraph{Zalety używania Pythona:}
\begin{itemize} 
	\item prosta, czytelna, klarowna składnia, zmniejszająca ilość potrzebnych linijek kodu w programach
	\item dynamicznie zarządza pamięcią oraz typy danych
	\item nie wymusza stylu programowania
	\item jest wieloplatformowy
	\item posiada bogaty zbiór różnego rodzaju bibliotek
	\item łatwy do nauczenia, nawet dla osób zaczynających programować
	\item szybkość działania w stosunku do innych języków kryptowych
\end{itemize} 
\mbox{} \\
Jeśli mielibyśmy dyskutować o wadach językach Python to ciężko jednoznacznie wskazać takie. Na pewno część z programistów może uznać zalety dynamicznego zarządzania typami jako wadę, ponieważ w niektórych przypadkach może spowodować błędy trudniejsze do znalezienia. Działania Pythona jest również wolniejsze w stosunku do języków takich jak C czy C++.  Za jedną z wad na pewno można uznać sposób programowania obiektowego jakie odbywa się w Pythonie. W szczególności nie ma enkapsulacji, istnieją metody które symulują takie działa, jednakże w stosunku do innych języków  obiektowych czytelność kodu zdecydowanie jest zmniejszona.

Język mimo swoich lat ciągle zyskuje na popularności. Ostatnio wszedł do pierwszej trójki najbardziej popularnych języków programowania według TIOBE\footnote{stan na grudzień 2018}, wyprzedzając między innymi język C++, a ulegając jedynie językowi Java oraz C. Wzrost języka Python na pewno można łączyć ze wzrostem popularności uczenia maszynowego i głębokich sieci, gdzie język Python jest jednym z najlepszych, jak nie najlepszym językiem w tych dziedzinach. Bardzo bogata biblioteka oraz przyjemna składnia sprawia, że język Python jest częściej wykorzystywany.  

Jako ciekawostkę można powiedzieć, że nazwa języka Python wzięła się nie od zwierzęcia, lecz od słynnego Brytyjskiego serialu "Monty Python’s Flying Circus".

\section{TensorFlow}
Jest to biblioteka programistyczna wykorzystywana w uczeniu maszynowym i głębokich sieciach neuronowych. Została wydana jako otwarte oprogramowanie przez Google Brain Team w dniu 9 listopada 2015.

Umożliwia pisanie programów m.in. w językach takich jak Python czy C. Jest dostępny na 64-bitowych systemach operacyjnych: Windows, Linux, macOS oraz na platformach mobilnych: Android oraz iOS. Zaś w maju 2017 został wydany TensorFlow Lite jako dedykowane rozwiązanie specjalnie dla użytkowników Androida.

Olbrzymią zaletą TensorFlow jest to, że reprezentuje on paradygmat Dataflow, w którym program ma postać grafu skierowanego modelującego przepływ danych pomiędzy niezależnymi operacjami w węzłach. W pierwszym kroku należy zdefiniować model, a następnie stworzyć tzw. TensorFlow session, która pozwala na uruchomienie programu. Takie podejście do pisania programów posiada ogromną zaletą jaką jest możliwość efektywnego programowania równoległego oraz rozproszonego. 

TensorFlow daje możliwość nie tylko wykorzystania CPU, ale równie dobrze korzystania z GPU. Wszystko to powoduje pełne wykorzystanie mocy obliczeniowej komputerów przy obliczeniach równoległych.

TensorFlow oprócz niskopoziomowych struktur posiada również moduły wyższego poziomu. Do modułów niskiego poziomu możemy odwoływać się poprzez warstwę API, która umożliwia łatwy do używania interfejs przeznaczony do modelów głębokiego uczenia. Zaś nad warstwą API znajduje się warstwa wysokiego poziomu, przykładem jej jest Keras.

\section{Keras}
Otwartoźródłowa biblioteka programistyczna napisana w języku Python wydana w dniu 27 marca 2015 napisana przez pierwotnego autora François Chollet. 

Jej głównym przeznaczeniem jest to, aby w jak najprostszy i  jak najszybszy sposób umożliwić pracę w głębokich sieciach neuronowych. Co więcej, biblioteka została zaprojektowana w sposób przyjemny do użytkowania, skupiona na modularności oraz rozszerzalności. Zaś od 2017 roku TensorFlow wspiera w swojej bibliotece Kerasa. Dzięki czemu Keras jest wysokopoziomową warstwą tworzenia modelów sieci neuronowych i jej uczenia.

\chapter{Gra papier, kamień, nożyce}
Jest to klasyczna gra towarzyska, w tradycyjnym wariancie przeznaczona dla dwóch graczy. W każdej rundzie każdy z graczy pokazuje gest przez siebie wybrany z trzech dostępnych. Wszystkie rundy odbywają się na ustalony wcześniej sygnał, a pokazywane gesty powinny być jak najbardziej zsynchronizowane. Gra kończy się wtedy, jeżeli jeden z graczy osiągnie określoną wcześniej ilość zwycięstw.


\paragraph{Trzy gesty dozwolone w grze:}
\begin{itemize} 
	\item Papier
	\item Kamień
	\item Nożyce
\end{itemize} 

\begin{figure}[H]
	\centering
	\subfigure[Gest papieru]
	{\label{fig:a}\includegraphics[width=0.3\textwidth]{\ImgPath/rys/gesty_gry/papier.png}}
	\subfigure[Gest kamienia]
	{\label{fig:b}\includegraphics[width=0.3\textwidth]{\ImgPath/rys/gesty_gry/kamien.png}}
	\subfigure[Gest nożyc]
	{\label{fig:b}\includegraphics[width=0.3\textwidth]{\ImgPath/rys/gesty_gry/nozyce.png}}
	\caption{BackgroundSubtractorKNN na gestach z gry papier, kamier, nożyce}
\end{figure}

Zwycięzca określany jest w zależności od kombinacji gestów pokazanych przez graczy. Jeżeli oba gracze pokazali ten sam gest, wówczas następuje remis. 

\paragraph{W przypadku kombinacji:}
\begin{itemize} 
\item papier-kamień - zwycięzcą zostaje gracz, który pokazał gest papieru
\item papier-nożyce - zwycięzcą zostaje gracz, który pokazał gest nożyc
\item kamień-nożyce - zwycięzcą zostaje gracz, który pokazał gest kamienia
\end{itemize} 
\mbox{} \\	
Zachowując takie zasady, każdy z gestów ma takie samo prawdopodobieństwo zwycięstwa. W grze liczy się w dużej mierze szczęście, ale także umiejętność przewidywania gestów przeciwnika.

\chapter{Rozpoznawanie gestów na przykładzie gry papier, kamień, nożyce}
\section{Aktywizacja danych}
Pierwszym etapem mojej pracy była aktywizacja danych potrzebnych do uczenia maszynowego. Zbieranie danych polegało na nagrywaniu plików wideo na których dana osoba wykonywała określony gest. W swojej pracy dyplomowej zakładam, że każdy wykonywany gest, jest pokazywany w niebieskiej rękawiczce. To założenie będę wykorzystywał w całej swojej pracy inżynierskiej.

\begin{figure}[H]	
	\centering
	\includegraphics[width=0.4\textwidth]{\ImgPath/rys/rekawiczki.jpg}
	
	\caption{Rękawiczki wykorzystywane w pracy inżynierskiej}
\end{figure}

Osoba podczas nagrywania wykonuje ciąg określonych gestów, w dowolnym odstępie czasie. Jest ona ustawiona prostopadle do kamery, co pozwala, aby gest odbywał się poprzez wyciągnięcie ręki oraz jego pokazanie. Na nagraniu zostaje zarejestrowany wykonywany gest, tak aby jedyną widoczna częścią ciała była prawa dłoń oraz ewentualnie cześć przedramienia. 

\begin{figure}[H]	
	\centering
	\includegraphics[width=0.6\textwidth]{\ImgPath/rys/klatka.jpg}
	
	\caption{Przykładowa klatka z nagrania}
\end{figure}

\paragraph{Do nagrywania plików wideo używałem dwóch kamer dedykowanych w laptopach:}
\begin{itemize}
	\item USB2.0 UVC HD Webcam
	\item HD Webcam
\end{itemize}
\mbox{} \\

Obie kamery pozwoliły na zadowalające efekty zbierania danych. Jakość nagrań przy dostatecznie dobrym oświetleniu była bardzo zadowalające, pozwalająca bez problem rozpoznawać wykonywany gest. Również liczba klatek na sekundę pozwoliła, aby dynamiczny ruch był płynny i łatwy do prawidłowego wysegmentowania.

W celu zebrania jak najszerszego zakres danych, zbieranie gestów nie ograniczyło się do jednej osoby, jednakże do pięciu różnych osób:
\begin{itemize}
	\item trzech kobiet
	\item dwóch mężczyzn
\end{itemize}
\mbox{} \\
\indent 
Zbieranie danych na różnych osobach pozwala na zmniejszenie wpływu charakterystycznych cech dla danej osoby:
\begin{itemize}
	\item długości dłoni
	\item szerokości dłoni
	\item ułożenia palców
	\item nachylenia dłoni
\end{itemize}
\mbox{} \\
\indent
Tak zebrane dane dają ogólny pogląd na różnorodność cech danego gestu. Sprawia, że uczenie maszynowe jest skuteczniejsze i daje oczekiwane rezultaty. 

Po zgromadzeniu całego materiału wideo, przeszedłem do etapu wyznaczania numerów klatek nagrań na których był moment wykonanego gestu. Informacje o numerach klatek gestów będę wykorzystywał w późniejszym etapie, przy segmentacji dłoni z wykonanym gestem.

\paragraph{W mojej pracy inżynierskiej wykorzystywałem zbiór danych składający się z:}
\begin{itemize}
	\item 350 próbek gestu papieru
	\item 350 próbek gestu kamienia
	\item 350 próbek gestu nożyc
\end{itemize}

Aby zapewnić prawidłowe rozpoznawanie, należy zgromadzić jak największą liczbę próbek gestów, która będzie w późniejszych etapach wykorzystywana przy uczeniu oraz weryfikacji klasyfikatorów.

\section{Detekcja ruchu}
Po zebraniu danych zająłem się ich przetwarzaniem. Pierwszym krokiem było wysegmentowanie obiektów, które znajdowały się w ruchu. Aby to osiągnąć należało wygenerować maskę binarną, która rozdziela elementy obrazu, która są w ruchu, od tych, które są elementami statycznymi. Do tego wykorzystałem tzw. background subtraction czyli tłumacząc z angielskiego ,,odejmowanie tła''.

W swojej pracy inżynierskiej w analizie wziąłem pod uwagę następujące dostępne funkcje w bibliotece OpenCV:

\begin{itemize} 
	\item BackgroundSubtractorMOG
	\item BackgroundSubtractorMOG2
	\item BackgroundSubtractorGMG
	\item BackgroundSubtractorKNN
	\item BackgroundSubtractorGSOC
	\item BackgroundSubtractorLSBP
\end{itemize} 

\begin{figure}[H]
	\centering
	\subfigure[BackgroundSubtractorKNN]
	{\label{fig:a}\includegraphics[width=0.3\textwidth]{\ImgPath/rys/bs/knn.png}}
	\subfigure[BackgroundSubtractorGSOC]
	{\label{fig:b}\includegraphics[width=0.3\textwidth]{\ImgPath/rys/bs/gsoc.png}}
	\subfigure[BackgroundSubtractorLSBP]
	{\label{fig:b}\includegraphics[width=0.3\textwidth]{\ImgPath/rys/bs/lsbp.png}}
	\caption{Przykładowe obrazy biorące udział w wyborze odpowiedniej funkcji usuwającej tło z biblioteki OpenCV}
\end{figure}

Po przeprowadzeniu licznych testów wywnioskowałem, że najlepszą metodą w mojej pracy inżynierskiej będzie funkcja z biblioteki OpenCV BackgroundSubtractorKNN. Uważam, że na przetestowanych próbkach segmentacja ruchu metodą tą dawała najlepsze rezultaty w porównaniu z innymi przetestowanymi metodami. Parametry funkcji przyjęły następującą końcową wartość:
\begin{enumerate}
	\item history: 200
	\item dist2Threshold: 8
	\item detectShadows: false
\end{enumerate}

\begin{figure}[H]
	\centering
	\subfigure[Znak papieru]
	{\label{fig:a}\includegraphics[width=0.3\textwidth]{\ImgPath/rys/bs/papier.png}}
	\subfigure[Gest kamienia]
	{\label{fig:b}\includegraphics[width=0.3\textwidth]{\ImgPath/rys/bs/kamien.png}}
	\subfigure[Gest nożyc]
	{\label{fig:b}\includegraphics[width=0.3\textwidth]{\ImgPath/rys/bs/nozyce.png}}
	\caption{Uzyskane rezultaty metodą BackgroundSubtractorKNN z biblioteki OpenCV}
\end{figure}


Można zauważyć, że wykonywany ruch dłonią jest bardzo widoczny, jednakże dodatkowo zawarta jest duża ilość szumu. Pozbycie się elementów dodatkowych, nieinteresujących nas części obiektów przedstawię w kolejnych podrozdziałach o detekcji kolorów oraz w podrozdziale o filtracji szumu. 

\section{Detekcja kolorów}
Równolegle do segmentacji obiektów w ruchu, zająłem się detekcją obiektów o określonym kolorze. W swojej pracy inżynierskiej założyłem, że każdy wykonywany gest jest pokazywany w niebieskiej rękawiczce, w celu łatwiejszej segmentacji dłoni. Nie użyłem tradycyjnego koloru skóry ze względu na fakt, że oprócz detekcji dłoni, spowodowałby także segmentację innych części ręki, takich jak twarz czy klatka piersiowa. Wszystko to mogłoby spowodować mniej precyzyjne rozpoznawanie gestu.

Wybrałem kolor niebieski ze względu na to, że jest to kolor dobrze rozróżniający się od innych, na który nie wpływa aż tak znacząco moc oświetlenia.
Jako, że każdy gest wykonywany jest w niebieskiej rękawiczce, mogłem wykorzystać ten fakt i przy pomocy modelu HSV określić zakres kątów barwy w tym modelu. 

\begin{figure}[H]	
	\centering
	\includegraphics[width=0.25\textwidth]{\ImgPath/rys/hsv.png}
	
	\caption{  \textbf{Model HSV}}
\end{figure}

Na powyżej przedstawionym modelu HSV, można łatwo zaobserwować, że kolor niebieski znajduje się w pewnym przedziale składowej H modelu HSV. To pozwala na zdecydowanie łatwiejsze określenie zakresu niż w przypadku modelu RGB. 
Chciałem tak dobrać przedział kolorów w modelu HSV, aby był możliwie jak najszerszy w celu dobrej detekcji dłoni. Zakres ten zawierał dodatkowo kolory zbliżone do niebieskiego oraz większość z jego odcieni. To pozwoliło na zwiększoną liczbę wykrytych pikseli, a w tym lepiej wysegmentowaną dłoń. Jednakże wszystko to również niesie za sobą różnego rodzaju szumy, które nie są związane z obiektem dłoni. 
\begin{figure}[H]
	\centering
	\subfigure[Znak papieru]
	{\label{fig:a}\includegraphics[width=0.3\textwidth]{\ImgPath/rys/detekcja_koloru/papier.png}}
	\subfigure[Gest kamienia]
	{\label{fig:b}\includegraphics[width=0.3\textwidth]{\ImgPath/rys/detekcja_koloru/kamien.png}}
	\subfigure[Gest nożyc]
	{\label{fig:b}\includegraphics[width=0.3\textwidth]{\ImgPath/rys/detekcja_koloru/nozyce.png}}
	\caption{Rezultaty detekcji dłoni w niebieskiej rękawiczce}
\end{figure}

\paragraph{Zakres modelu HSV jaki wykorzystałem w swojej pracy inżynierskiej jest następujący:}
\begin{enumerate}
	\item od HSV (98,50,20)
	\item do HSV (130,255,255)
\end{enumerate}
\mbox{} \\

Jak widzimy występuje znacząca liczba szumu, jednakże jeżeli połączymy detekcję koloru niebieskiego z detekcją ruchu, która została opisana w poprzednim podrozdziale, może pozbyć się w większości tych niechcianych elementów. 

\begin{figure}[H]
	\centering
	\subfigure[Znak papieru]
	{\label{fig:a}\includegraphics[width=0.3\textwidth]{\ImgPath/rys/bs_color/papier.png}}
	\subfigure[Gest kamienia]
	{\label{fig:b}\includegraphics[width=0.3\textwidth]{\ImgPath/rys/bs_color/kamien.png}}
	\subfigure[Gest nożyc]
	{\label{fig:b}\includegraphics[width=0.3\textwidth]{\ImgPath/rys/bs_color/nozyce.png}}
	\caption{Rezultaty detekcji dłoni w niebieskiej rękawiczce oraz wykrywania ruchu}
\end{figure}

Jak widzimy większość z niepożądanych szumów została usunięta za sprawą połączania dwóch masek binarnych. Możemy też zaobserwować, że nie wszystko zostało prawidłowo przefiltrowane, mogły też pozostać tzw. dziury binarne czyli części obiektów, które nie zostały zakwalifikowane jako części obiektu, a nimi faktyczne są. 

Wszystko to powoduje, że konieczne są kolejne filtracje szumów. W tym przypadku wykorzystałem operacje morfologiczne na obrazach binarnych, co opiszę w następnym podrozdziale.  

\section{Filtracja szumów}
Połączenie iloczynowe maski binarnej uzyskanej z segmentacji obiektów w ruchu oraz maski binarnej z obiektami o określonym kolorze niesie za sobą możliwe niedokładności, których dla polepszenia efektowności rozpoznawania gestów należy zminimalizować. Odbywa się to poprzez zastosowanie operacji morfologicznych na obrazie binarnym. 

\paragraph{Dodatkowe elementy:} \mbox{} \\
Pierwszym problemem po wygenerowaniu maski binarnej można uznać wszystkie dodatkowe elementy, które nie powinny być zakwalifikowane jako część dłoni. Segmentacja elementów obrazu w ruchu, może nieść ze sobą różnego rodzaju szum spowodowany tym, że inne obiekty, różne od naszej dłoni też mogą się poruszać, co w wyniku generacji maski binarnej zostaną też wzięte pod uwagę. Kolejnym problem są także wszystkie te pikseli, które są koloru niebieskiego lub też są zbliżone do niego, a więc przy wyłuskiwaniu wszystkich pikseli o kolorze rękawiczki, czyli w kolorze niebieskim, zostaną uwzględnione jako obiekt.

\begin{figure}[H]
	\centering
	\subfigure[Maska binarna przed operacją morfologiczną erozji]
	{\label{fig:a}\includegraphics[width=0.47\textwidth]{\ImgPath/rys/szumy/przed_erozja.png}}
	\subfigure[Maska binarna po operacji morfologicznej erozji]
	{\label{fig:b}\includegraphics[width=0.47\textwidth]{\ImgPath/rys/szumy/po_erozji.png}}
	\caption{  \textbf{Zastosowanie operacji morfologicznej erozji z elementem strukturalnym kwadratu o boku 8 pikseli}}
\end{figure}

Zastosowanie operacji morfologicznej erozji na masce binarnej powoduje usunięcie elementów niechcianych, które są traktowane jako dodatkowy, niepotrzebny szum. W swojej pracy inżynierskiej wykorzystałem w pierwszym kroku filtracji masek binarnych operację morfologiczną erozji z bardzo małym elementem strukturalnym, bo z kwadratem o boku 2. Różniejsza operacja erozji, po wykonaniu operacji zamknięcia odbywała się już z większym wielkością elementem strukturalnym: kwadratem o boku 8.  Wykorzystanie takiej operacji dało zadowalające efekty w mojej ocenie, które pozwolą w późniejszym etapie pracy na dokładniejsze rozpoznawanie gestów.

\paragraph{Ubytku w dłoni:} \mbox{} \\
Oprócz pozbycia się dodatkowych elementów na obrazie binarnym należy także, wypełnić luki które mogły się pojawić podczas segmentacji obiektów w ruchu oraz przy uzyskiwaniu maski binarnej z obiektami o określonym kolorze. Są one spowodowane tym, że pewne części z obrazów podczas tych operacji nie zostały prawidło zakwalifikowane. Zbyt mocne lub też zbyt słabe światło czy też pojawiające się cienie mogły wpłynąć na kolor niebieskiej rękawiczki, a przez to spowodować niedokładne wykrycie. Również gest ręki mógł być bardzo powolny, a przez to nie zostanie uznana pełna dłoń jako element w ruchu przez operacje segmentacji ruchu. Zarówno też dynamiczny ruch ręku w połączeniu z występujących w otoczeniu światłem wpływa na odbierany kolor rękawiczki. Należy też dodatkowo wziąć pod uwagę dziury w obrazie binarnym, który mogły wyniknąć z operacji morfologicznej erozji, która została zastosowana jako pierwsza. 

\begin{figure}[H]
	\centering
	\subfigure[Maska binarna przed operacją morfologiczną dylatacji]
	{\label{fig:a}\includegraphics[width=0.47\textwidth]{\ImgPath/rys/szumy/przed_dylatacja.png}}
	\subfigure[Maska binarna po operacji morfologicznej dylatacji]
	{\label{fig:b}\includegraphics[width=0.47\textwidth]{\ImgPath/rys/szumy/po_dylatacji.png}}
	\caption{  \textbf{Zastosowanie operacji morfologicznej dylatacji z elementem strukturalnym kwadratu o boku 11 pikseli}}
\end{figure}

Zastosowanie operacji morfologicznej dylatacji na masce binarnej powoduje wypełnienie dziur, które mogły wystąpić w masce binarnej. W swojej pracy inżynierskiej do pozbycia się różnego rodzaju dziur w maskach binarnych  użyłem operacji morfologicznej dylatacji z elementem strukturalnym kwadratu o boku 11. 

\begin{figure}[H]
	\centering
	\subfigure[Gest kamienia przed filtracją ]
	{\label{fig:a}\includegraphics[width=0.45\textwidth]{\ImgPath/rys/szumy/1.png}}
	\subfigure[Gest kamienia po filtracji]
	{\label{fig:b}\includegraphics[width=0.45\textwidth]{\ImgPath/rys/szumy/2.png}}
	\caption{  \textbf{Przykładowe maski binarne po zastosowaniu operacji morfologicznych erozji oraz dylatacji z elementami strukturalnymi kwadratu o boku 8 dla erozji oraz kwadratu o boku 11 dla operacji dylatacji}}
\end{figure}

W swojej pracy inżynierskiej zastosowałem następujące operacje do przefiltrowania masek binarnych: 
\begin{enumerate}
	\item operację morfologiczną erozji na masce binarnej z elementem strukturalnym kwadratu o boku 4
	\item operację morfologiczną zamknięcia z elementem strukturalnym kwadratu o boku 8 na wyjściowej masce binarnej uzyskanej w podpunkcie nr 1
	\item operację morfologiczną dylatacji z elementem strukturalnym kwadratu o boku 11 na wyjściowej masce binarnej uzyskanej w podpunkcie nr 2
	\item operację morfologiczną dylatacji z elementem strukturalnym kwadratu o boku 11 na wyjściowej masce binarnej uzyskanej w podpunkcie nr 3
\end{enumerate}

\begin{figure}[H]
	\centering
	\subfigure[Gest papieru ]
	{\label{fig:a}\includegraphics[width=0.3\textwidth]{\ImgPath/rys/szumy/p.png}}
	\subfigure[Gest kamienia]
	{\label{fig:b}\includegraphics[width=0.3\textwidth]{\ImgPath/rys/szumy/k.png}}
	\subfigure[Gest nożyc]
	{\label{fig:b}\includegraphics[width=0.3\textwidth]{\ImgPath/rys/szumy/n.png}}
	\caption{  \textbf{Przykłady efektów wykonanej filtracji, która została powyżej opisana}}
\end{figure}

Cała filtracja  w mojej ocenie bardzo dobre rezultaty, które znacząco polepszyły prawidłową segmentację dłoni, a przez to w późniejszych krokach dokładniejsze rozpoznawanie dłoni.

\section{Znajdowanie obiektów}
Ostatnim etapem przetwarzania obrazów w mojej pracy inżynierskiej było wydzielenie z maski binarnej prostokąta, zawierającego w sobie całą wysegmentową wcześniej dłoń, bez ogólnego tła. Dzięki czemu jesteśmy wstanie analizować jedynie tą część maski binarnej, która zawiera w sobie całą dłoń, bez zbędnych innych elementów.

Znajdowanie to polegało na wyszukaniu prostokąta na całej masce binarnej, która będzie miała największe pole ze wszystkich znalezionych konturów na obiektach z maski binarnej. 

\begin{figure}[H]
	\centering
	{\label{fig:a}\includegraphics[width=0.45\textwidth]{\ImgPath/rys/obcinanie/znalezienie.jpg}}
	\caption{  \textbf{Zaznaczenie na czerwono prostokąta o największym polu, który zawiera w sobie całościowo obiekt}}
\end{figure}

Po znalezieniu takiego prostokąta następowało przycięcie maski do odpowiednich rozmiarów zgodnie z znalezionym prostokątem o największym polu. Prostokąt ten jest przyległy przez obiekt binarny z każdej swojej strony, co oznacza, że dokładnie przycięcie nie jest możliwe, bez zmniejsza znalezionego obiektu.

\begin{figure}[H]
	\centering
	{\label{fig:b}\includegraphics[width=0.45\textwidth]{\ImgPath/rys/obcinanie/obcinanie.png}}
	\caption{  \textbf{Obcięcie zgodnie ze znalezionym prostokątem}}
\end{figure}
\paragraph{Etapy przycięcia maski binarnej:}
\begin{enumerate}
	\item Przypisz do obecnie znalezionego największego pola prostokąta wartość~0
	\item Znajdź wszystkie kontury obiektów na masce binarnej
	\item Dla każdego konturu wykonaj:
	\begin{enumerate}
		\item Oblicz współrzędne lewego górnego oraz prawego dolnego wierzchołka prostokąta, który będzie otaczał analizowany kontur 
		\item Oblicz pole powierzchni tak utworzonego prostokąta
		\item Jeżeli pole powierzchni utworzonego prostokąta jest większe niż pole powierzchni obecnie znalezionego największego prostokąta, to traktur tą powierzchnię jako największą i dodatkowo zapamiętaj współrzędne prostokąta
	\end{enumerate}
	\item Przytnij maskę binarną o zapamiętanych wierzchołkach największego znalezionego prostokąta
\end{enumerate}

Efekt końcowy wysegmentowania dłoni zawiera w sobie obiekt binarny reprezentujący dłoń, którą jest wykonywany gest.
Zostanie on wykorzystany przez klasyfikatory opisany w następnych podrozdziałach klasyfikatora KNN oraz klasyfikatora opartego o sieci neuronowe.
\begin{figure}[H]
	\centering
	\subfigure[Gest papieru ]
	{\label{fig:a}\includegraphics[width=0.3\textwidth]{\ImgPath/rys/obcinanie/p.png}}
	\subfigure[Gest kamienia]
	{\label{fig:b}\includegraphics[width=0.3\textwidth]{\ImgPath/rys/obcinanie/k.png}}
	\subfigure[Gest nożyc]
	{\label{fig:b}\includegraphics[width=0.3\textwidth]{\ImgPath/rys/obcinanie/s.png}}
	\caption{  \textbf{Końcowa segmentacja dłoni}}
\end{figure} 

\section{Dobór i ocena cech}
Po wysegmentowaniu gestów dla uczenia maszynowego przeszedłem do etapu opisu odpowiednimi cechami zgromadzonego materiału. Skupiłem się, na właściwościach binarnych jakie one przedstawiają.

\paragraph{Zdecydowałem się, że gesty będę opisywał za pomocą następujących cech}
\begin{itemize}
	\item Stosunek szerokości do długości 
	\item Stosunek powierzchni znalezionego obiektu dłoni do powierzchni całego obrazu
	\item Stosunek powierzchni otoczki wypukłej utworzonej na znalezionej dłoni do powierzchni całego obrazu
\end{itemize}

Pierwszym krokiem przy analizowaniu cech opisujących dane było wyliczenie średnich w obrębie określonego gestu.

\begin{table}[H]
	\centering
	\begin{tabularx}{\textwidth}{|X|l|l|l|}
		\hline
		\textbf{Nazwa cechy} & \textbf{Papier} & \textbf{Kamień} & \textbf{Nożyce} \\ 
		
		\hline
		Stosunek szerokości do długości & 0.43 & 0.59 & 0.78 \\ 
		
		\hline
		Stosunek powierzchni obiektu dłoni do powierzchni całego obrazu & 0.48 & 0.38 & 0.84 \\ 
		
		\hline
		Stosunek powierzchni otoczki wypukłej utworzonej na znalezionej dłoni do powierzchni całego obraz & 0.35 & 0.62 & 0.84 \\ 
		\hline
	\end{tabularx}

	\caption{Wartości średnie}
\end{table}

Przy ocenie jakości dobranych cech wykorzystałem odchylenie standardowe. Dzięki niemu byłem wstanie porównać jak dana cecha jest porozrzucana w obrębie określonego gestu.

\begin{table}[H]
	\centering
	\begin{tabularx}{\textwidth}{|X|l|l|l|}
		\hline
		\textbf{Nazwa cechy} & \textbf{Papier} & \textbf{Kamień} & \textbf{Nożyce} \\ 
		
		\hline
		Stosunek szerokości do długości & 0.10 & 0.18 & 0.05 \\ 
		
		\hline
		Stosunek powierzchni obiektu dłoni do powierzchni całego obrazu & 0.09 & 0.10 & 0.04 \\ 
		
		\hline
		Stosunek powierzchni otoczki wypukłej utworzonej na znalezionej dłoni do powierzchni całego obraz & 0.10 & 0.16 & 0.05 \\ 
		\hline
	\end{tabularx}
	
	\caption{Odchylenie standardowe}
\end{table}

Po przeanalizowaniu odchyleń standardowych doszedłem do wniosku, że wszystkie trzy, wcześniej wybrane cechy są odpowiednie, aby je wykorzystać do stworzenia klasyfikatora. Odchylenie dla danej cechy, w obrębia określonego gestu nie były dużą wartością, co oznacza, że cecha ta nadaje się dobrze, aby ją wykorzystać przy rozpoznawaniu gestów, zgodnie ze wzorem: $ Z = \dfrac{x - \mu}{\sigma} $, gdzie x - wartość przed normalizacją, $\mu$ - średnia, $\sigma$ - odchylenie standardowe

\section{Rozpoznawanie gestów przy pomocy klasyfikatora KNN}
Dla klasyfikatora KNN przygotowałem następujące zestaw cechy opisujących maskę binarną: 
\begin{itemize}
	\item Stosunek szerokości do długości obrazu
	\item Stosunek powierzchni znalezionego obiektu dłoni do powierzchni całego obrazu
	\item Stosunek powierzchni otoczki wypukłej utworzonej na znalezionej dłoni do powierzchni całego obrazu
\end{itemize}

Każda z cech została poddana etapowi normalizacji w postaci standaryzacji. Dzięki niej każda cecha wpływa równomiernie na decyzję podejmowaną przez klasyfikator.

Klasyfikator został oparty na klasycznej odległości euklidesowej. Zbiór danych, który został opisany w poprzedni rozmiarach składał się z 1050 różnych próbek danych. Został on podzielony w stosunku 8:2, dzięki czemu zbiór uczący liczył 855 próbek, zaś zbiór weryfikacyjny zawierał 195 próbek. 

\paragraph{W zależności od doboru parametry klasyfikator k, osiągnąłem następujące wyniki:}
{\centering
\paragraph{k = 3}
	\mbox{}\\
	Średnia dokładność klasyfikatora: \textbf{83.76\%}
\paragraph{k = 5}
	\mbox{}\\
	Średnia dokładność klasyfikatora: \textbf{86.08\%}
\paragraph{k = 7}
	\mbox{}\\
	Średnia dokładność klasyfikatora: \textbf{82.41\%}
\paragraph{k = 9}
	\mbox{}\\
	Średnia dokładność klasyfikatora: \textbf{81.68\%} \par
}
	\begin{figure}[H]
		\centering
		{\label{fig:b}\includegraphics[width=0.60\textwidth]{\ImgPath/rys/klasyfikatory/knn.png}}
		\caption{  \textbf{Uruchomienie klasyfikatora KNN}}
	\end{figure}
	
Z wykonanych analiz dokładności klasyfikatorów w zależności od parametru k wynika, że najlepsze efekty można było osiągnąć używając klasyfikatora KNN z parametrem k o wartości 5, który działał ze średnią dokładnością \textbf{86.08\%}.
\section{Rozpoznawanie gestów przy pomocy sieci neuronowej}
\subsection{Sieć neuronowa dla cech}
	Analogicznie jak w przypadku klasyfikatora KNN również i  kolejny klasyfikator oparłem na wyznaczonych wcześniej cechach. Klasyfikator ten różnił się tym od poprzedniego, że bazował tym razem na sieciach neuronowych. A swoją skuteczność klasyfikacji zawdzięcza uczeniu maszynowemu.
	
	Sieć została stworzona w języku Python, korzystając z biblioteki TensorFlow oraz jako wysokopoziomowe API sieci neuronowych wykorzystałem bibliotekę Keras.
	
	\paragraph{Sieci neuronowe, które wykorzystywałem przy budowie klasyfikatora składały się z następujących części:}
	\begin{enumerate}
		\item Warstwa wejściowa
		\item Jedna warstwa ukryta
		\item Warstwa wyjściowa
	\end{enumerate}

	\paragraph{Do warstwy wejściowej były podawane wartości następujących cech:}
	\begin{itemize}
		\item Stosunek szerokości do długości obrazu
		\item Stosunek powierzchni znalezionego obiektu dłoni do powierzchni całego obrazu
		\item Stosunek powierzchni otoczki wypukłej utworzonej na znalezionej dłoni do powierzchni całego obrazu
	\end{itemize}
	\noindent
	Każda z cech została poddana etapowi normalizacji w postaci standaryzacji, która zdecydowanie korzystnie wpływała na skuteczność klasyfikacji.
	
	Zbiór uczący sieci neuronowe zawierał 855 próbek, zaś zbiór weryfikacyjny zawierał w sobie 195 próbek. Każdy z trzech gestów miał po 350 próbek, zaś przydział do odpowiedniego zbioru odbywał się w sposób losowy.
	
	Warstwa wyjściowa każdej z przetestowanych sieci, składała się z funkcji aktywacji softmax, której wyjście traktowałem jako prawdopodobieństwo danego z trzech gestów. Każdy z trzech neuronów wyjściowych oznaczyły właśnie to prawdopodobieństwo w następującej kolejności:
	\begin{enumerate}
		\item gest papieru
		\item gest kamienia
		\item gest nożyc
	\end{enumerate}
	
	Pierwszym zbiorem sieci jaki przetestowałem były to sieci z jedną warstwą ukrytą. Do uczenia sieci wykorzystywałem metodę GradientDescentOptimizer z parametrem uczenia równym 0.01. Zaś sama sieć została uruchomiana dla 100 epok. Zaś ilość neuronów w warstwie ukrytej oraz funkcje aktywacji dla tej warstwy i warstwy wejściowej były to parametry, które doświadczalnie zmieniałem.
	
	\paragraph{Zanotowałem następujące dokładności rozpoznawania siecią przy wyżej wymienionych parametrach:}
	
	\mbox{}\\
	
	\begin{table}[H]
		\centering
		\begin{tabularx}{\textwidth}{|X|X|X|X|}
			\hline
			\textbf{} & \textbf{ReLU funkcją aktywacji} & \textbf{Sigmoid funkcją aktywacji}  & \textbf{Tanh funkcją aktywacji}  \\ 
			
			\hline
			2 neurony w warstwie ukrytej & 57.54\% & 63.29\% & 74.28\% \\ 
			
			\hline
			4 neurony w warstwie ukrytej & 80.05\% & 64.52\% & 81.35\% \\
			
			\hline
			6 neuronów w warstwie ukrytej & 83.43\% & 69.01\% & 83.08\% \\
			
			\hline
			8 neuronów w warstwie ukrytej & 81.59\% & 67.54\% & 77.26\% \\
			
			\hline
			10 neuronów w warstwie ukrytej & 80.03\% & 64.21\% & 78.11\% \\
			
			\hline
			12 neuronów w warstwie ukrytej & 79.89\% & 57.63\% & 76.41\% \\
			
			\hline
			15 neuronów w warstwie ukrytej & 81.28\% & 65.59\% & 79.62\% \\
			
			\hline
			20 neuronów w warstwie ukrytej & 78.82\% & 61.77\% & 80.09\% \\
			
			\hline
			25 neuronów w warstwie ukrytej & 78.55\% & 54.23\% & 77.78\% \\
			
			\hline
			50 neuronów w warstwie ukrytej & 77.73\% & 60.19\% & 79.13\% \\ 
			\hline
		\end{tabularx}
		
		\caption{Skuteczność sieci neuronowej}
	\end{table}
	
	Po przeprowadzonych doświadczeniach okazało się, że najlepsze wyniki można było uzyskać siecią neuronową składającą się z 6 neuronów w warstwie ukrytej, przy wykorzystywaniu funkcji aktywacji ReLU w warstwie wejściowej oraz w warstwie ukrytej. Wszystkie wartości zostały przedstawione dla 100 epok uczenia sieci.
	
	W następnym etapie swojej pracy przeanalizowałem, wpływ ilości epok podczas uczenia sieci. Testowanie odbyło się na sieci, która dała najlepsze rezultaty w poprzednim doświadczeniu.
	\paragraph{Analiza uczenia w poszczególnych epokach:}
	\mbox{}\\
	
	\begin{figure}[H]
		\centering
		{\label{fig:b}\includegraphics[width=0.90\textwidth]{\ImgPath/rys/opoki.png}}
		\caption{  \textbf{Skuteczność uczenia sieci w zależności od ilości epok uczenia}}
	\end{figure}

	Na wykresie można zaobserwować bardzo dynamiczny wzrost skuteczności uczenia, dla pierwszych 50 epok. Kolejnym 50 epokach następuje również sporo wzrost skuteczności, jednakże już nie tak gwałtowny. Uczenie przy ponad 100 opokach daje to coraz mniejszy wzrost skuteczności uczenia, co można z łatwością zobaczyć na wykresie. Analiza ta spowodowała, że sieci neuronowe będę uczył dla 100 epok.
	
	Ostatnim parametrem, który przeanalizowałem był dobór parametru szybkości uczenia w metodzie GradientDescentOptimizer, wpływa on w jak szybki sposób zbliżamy się do optymalnego rozwiązania według wyliczonego gradientu.
	
		\begin{table}[H]
		\centering
		\begin{tabularx}{\textwidth}{|X|X|X|X|}
			\hline
			\textbf{Szybkość uczenia} & \textbf{Skuteczność sieci neuronowej}    \\ 
			
			\hline
			0.001 & 67.19\% \\ 
			
			\hline
			0.010 & 83.43\% \\
			
			\hline
			0.020 & 78.91\% \\
			
			\hline
			0.050 & 80.37\% \\
			
			\hline
			0.100 & 80.34\% \\
			
			\hline
			0.150 & 79.88\% \\
			
			\hline
			0.200 & 80.02\% \\
			
			\hline
			0.250 & 81.11\% \\
			
			\hline
			0.500 & 82.78\% \\
			\hline
		\end{tabularx}
		
		\caption{Skuteczność sieci neuronowej w zależności od współczynnika szybkości uczenia}
	\end{table}

	Większość z prób była do siebie zbliżona skutecznością. W wykonanych doświadczeniach sieć dawała najlepsze rozwiązania dla parametru szybkości uczenia o wartości: 0.01.
	
	\begin{figure}[H]
		\centering
		{\label{fig:b}\includegraphics[width=0.98\textwidth]{\ImgPath/rys/klasyfikatory/siec_cechy.png}}
		\caption{  \textbf{Uruchomienie sieci neuronowej}}
	\end{figure}

	\paragraph{Przeprowadzona analiza pozwoliła ustalić ostateczne parametry sieci:}
	\begin{itemize}
		\item Sieć składa się z następujących warstw: warstwa wejściowa, jedna warstwa ukryta, warstwa wyjściowa
		\item Warstwa wejściowa składa się z trzech neuronów reprezentujące wartości cech dla danej próbki, zaś funkcją aktywacji neuronów tej warwie jest funkcja ReLU
		\item Warstwa ukryta składa się z 6 neuronów, a funkcja aktywacji każdego z nich to również ReLU
		\item Warstwa wyjściowa składa się z trzech neuronów, które reprezentują prawdopodobieństwo gestu w kolejności: papier, kamień, nożyce. Funkcja aktywacja dla każdego z neuronów to softmax.
		\item Sieć była uczona na 100 epokach
		\item Jako metodę uczenia uczenia wykorzystałem dostępny w bibliotece Keras GradientDescentOptimizer, ze współczynnikiem uczenia 0.01
		\item Sieć była uczona 855 próbkami zbioru uczącego
		\item Sieć była testowana 195 próbkami zbioru weryfikującego
	\end{itemize}
	\mbox{}
	\\
	Sieć z podanymi wyżej parametrami dała średnią skuteczność na poziomie \textbf{83.43\%}. Jest to wartość zadowalająca, zbliżona do wartości jaka została uzyskana za pomocą klasyfikatora KNN.
\subsection{Sieć neuronowa obrazów binarnych}


	Kolejnym podejściem do klasyfikacji była analiza wysegmentowanej dłoni gestu siecią neuronową tym razem bez opisywania gestu cechami, lecz podaniem do klasyfikatora całego otrzymanego wcześniej obrazu binarnego.
	
	Po procesie segmentacji dłoni z gestem, opisanym w poprzednich podrozdziałach, należało ustandaryzować rozmiar obrazu binarnego, który został wykorzystany jako element wejścia dla sieci neuronowej. Ustaliłem, że rozmiar będzie wynosił 60 pikseli szerokości oraz 25 pikseli wysokości. Stosunek obu wartości chciałem tak dobrać, aby zachował jak najbardziej ogólną jego wartość dla wszystkich obrazów binarnych z wykorzystywanego zbioru danych. Zmniejszenie rozmiaru, ma również korzystny wpływ na szybkość działania sieci, jednakże w wyniku czego tracimy pewne dostępne szczegóły na obrazie.

	Sieć została stworzona w języku Python, korzystając z biblioteki TensorFlow oraz jako wysokopoziomowe API sieci neuronowych wykorzystałem bibliotekę Keras.

	Zbiór uczący sieci neuronowe zawierał 855 próbek, zaś zbiór weryfikacyjny zawierał w sobie 195 próbek. Każdy z trzech gestów miał po 350 próbek, zaś przydział do odpowiedniego zbioru odbywał się w sposób losowy.
	
	\paragraph{Sieci neuronowe, które wykorzystywałem przy budowie klasyfikatora składały się z następujących części:}
	\begin{enumerate}
		\item Warstwa wejściowa
		\item Jedna warstwa ukryta
		\item Warstwa wyjściowa
	\end{enumerate}
	
	Jako elementy wejścia były wykorzystywane wysegmentowane wcześniej obrazy dłoni z gestem i skonwertowane do rozmiaru 60 pikseli szerokości i 25 pikseli wysokości. Wartości pikseli obrazu rgb zostały przeskalowane z przedziału 0-255 do wartości z przedziału 0-1. 
	Do warstwy wejściowej sieci, podane zostały wartości tablicy o rozmiarze 25x60x3, która zawierała przeskalowane wartości rgb pikseli obrazu dłoni.
	Ilość neuronów w warstwie ukrytej był to parametr, który doświadczalnie zmieniałem. Funkcja aktywacji jaką wykorzystałem dla tej warstwy była to funkcja RuLU.

	Warstwa wyjściowa każdej z przetestowanych sieci, składała się z funkcji aktywacji softmax, której wyjście traktowałem jako prawdopodobieństwo danego z trzech gestów. Każdy z trzech neuronów warstwy wyjścia oznaczał właśnie to prawdopodobieństwo w następującej kolejności:
	\begin{enumerate}
		\item gest papieru
		\item gest kamienia
		\item gest nożyc
	\end{enumerate}

	\paragraph{Budowa sieci neuronowej korzystając z biblioteki Keras:}
	\begin{lstlisting}[language=Python]
   model = keras.Sequential([
     keras.layers.Flatten(input_shape=(25, 60, 3)),
     keras.layers.Dense(256, activation=tf.nn.relu),
     keras.layers.Dense(3, activation=tf.nn.softmax)
   ])
	\end{lstlisting}
	
	Do uczenia sieci neuronowych wykorzystywałem metodę dostępną w bibliotece Keras GradientDescentOptimizer z parametrem uczenia równym 0.01. Zaś sama sieć została uruchomiana dla 100 epok. 
	
	\paragraph{Zanotowałem następujące dokładności rozpoznawania siecią przy wyżej wymienionych parametrach:}
	
	\mbox{}\\
	
	\begin{table}[H]
		\centering
		\begin{tabularx}{\textwidth}{|X|X|X|X|}
			\hline
			\textbf{Liczba neuronów w warstwie ukrytej sieci} & \textbf{Dokładność klasyfikacji} \\ 
			
			\hline
			32  & 98.13\% \\ 
			
			\hline
			64  & 98.46\% \\
			
			\hline
			128  & 99.18\% \\
			
			\hline
			256  & 99.58\% \\
			
			\hline
			512  & 98.88\% \\
			
			\hline
		\end{tabularx}
		
		\caption{Skuteczność sieci neuronowej}
	\end{table}

	Powyższe wartości dokładności rozpoznawania gestów przez sieć neuronową pokazują, że wyśmienicie sobie radzi z klasyfikacją gestów. Najlepsze rezultaty dawała sieć zbudowana z 256 neuronów w warstwie ukrytej. Średnia jej skuteczność to ponad 99\% co sprawia, że rozpoznawanie gestów można uznać praktycznie za bezbłędne. 
	
	\begin{figure}[H]
		\centering
		{\label{fig:b}\includegraphics[width=0.98\textwidth]{\ImgPath/rys/klasyfikatory/siec.png}}
		\caption{  \textbf{Uruchomienie sieci neuronowej}}
	\end{figure}
	

\chapter{Podsumowanie}
	W niniejszej pracy inżynierskiej opisano podejście do rozpoznawania gestów na przykładzie gry papier, kamień, nożyce. Wykorzystując bibliotekę OpenCV przedstawiono w jaki sposób można wysegmentować dłoń. Techniki opisane w pracy z według mojej oceny dały bardzo dobre rezultaty. Segmentacja gestu pozwoliła na wyraźne wyłuskanie dłoni wykonującej gest.
	
	Segmentacja była pierwszym etapem przy procesie poznawania gestów. Po nim zaś nastąpił bezpośredni proces klasyfikacji dłoni. W pierwszym sposobie podejścia do klasyfikowania jakim był klasyfikator KNN. Klasyfikator ten dla odpowiednich parametrów osiągnął średnią skuteczność 86.08\%, zakładając użycie trzech cech opisujących wysegmentowaną dłoń uważam, że jest to zadowalająca skuteczność.
	
	Drugim zaś podejściem do klasyfikacji był klasyfikator oparty o sieci neuronowe. Przy jego wykorzystaniu skuteczność rozpoznawania zdecydowanie przewyższyła klasyfikator KNN. Rozpoznawanie takie było praktycznie bezbłędne na zgromadzonym zestawie danych, ponieważ klasyfikator przy uzyskanych najlepszych parametrach osiągał skuteczność powyżej 99\%, co w moim przeświadczeniu jest wyśmienitym rezultatem, biorąc pod uwagę cały proces rozpoznawania gestów.
	
	W mojej ocenie cel jaki na początku swojej  pracy założyłem, czyli prawidłowe rozpoznawanie trzech gestów papieru, kamienia oraz nożyc, został osiągnięty z sukcesem. Klasyfikator oparty na sieciach neuronowych pokazał jak  wielkie możliwości daje wykorzystanie sztucznych sieci neuronowych, które coraz częściej są wykorzystywane w naszym codziennym życiu. 

	\paragraph{Jak można rozbudować tą pracę inżynierską: }
		\begin{enumerate}
			\item Zgromadzenie większego zbioru danych 
			\item Wyekstrahowanie większej ilości cech dla klasyfikatora KNN 
			\item Porównanie klasyfikatora KNN z innymi klasyfikatorami
			\item Wykorzystanie sieci CNN
			\item Klasyfikacja dłoni bez użycia rękawiczki
			\item Zaimplementowanie gry dla wielu graczy wykorzystując stworzone klasyfikatory
			\item Dodanie do klasyfikacji kolejnych gestów
		\end{enumerate}


\appendix



\begin{thebibliography}{99}


\end{thebibliography}


\end{document}
